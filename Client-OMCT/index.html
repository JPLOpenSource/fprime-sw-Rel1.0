<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>FPrime</title>    

  <!-- Open MCT Ditribution and plugins -->
  <!-- OMCT -->
  <script src="node_modules/openmct/dist/openmct.js"></script>
  <!-- Server requests -->
  <script src="client/js/http.js"></script>
  <!-- Get dictionary -->
  <script src="client/js/get-dict.js"></script>
  <!-- Get dictionary plugin-->
  <script src="client/plugins/dictionary-plugin.js"></script>
  <!-- Realtime telemetry plugin -->
  <script src="client/plugins/realtime-telem-plugin.js"></script>
  <!-- Historical telemetry plugin -->
  <script src="client/plugins/historical-telem-plugin-local.js"></script>
  <!-- Create views from local storage json -->
  <script src="client/plugins/loc-storage-objects.js"></script>
  <script src="client/plugins/limit-eval.js"></script>
  <!-- <link href="client/css/limit.css" media="all" rel="stylesheet" type="text/css"/> -->




  <!-- console -->
  <!-- <script src="client/js/vue-console.js" type="text/javascript"></script> -->
  <!-- Console style -->
  <!-- <link href="client/css/console.css" media="all" rel="stylesheet" type="text/css"/> -->

</head>
<body>
  <script type="text/javascript">
    // Load views
    LoadViews();

    // OpenMCT
    const site = 'localhost';
    const staticPort = 8080;
    const realTelemPort = 1337;
    const histTelemPort = 1338;

    openmct.setAssetPath('node_modules/openmct/dist');
    openmct.install(openmct.plugins.LocalStorage()); // Save user-created views locally
    // openmct.install(openmct.plugins.CouchDB('http://' + site + ':' + histTelemPort.toString()));
    openmct.install(openmct.plugins.MyItems());

    // Configure time system
    openmct.install(openmct.plugins.UTCTimeSystem());
    openmct.install(openmct.plugins.LADTable());
    openmct.install(openmct.plugins.Conductor({
      menuOptions: [
        {
          name: "Fixed",
          timeSystem: 'utc',
          bounds: {
            start: Date.now() - 5 * 60 * 1000,
            end: Date.now()
          }
        },
        {
          name: "Realtime",
          timeSystem: 'utc',
          clock: 'local',
          clockOffsets: {
            start: -10 * 60 * 1000,
            end: 0 * 60 * 1000
          }
        }
      ]
    }));
    openmct.time.clock('local', {start: -1 * 60 * 1000, end: 0});
    openmct.time.timeSystem('utc');

    // Theme
    openmct.install(openmct.plugins.Snow());

    // User plugin installs
    openmct.install(DictionaryPlugin(site, staticPort));
    openmct.install(RealtimeTelemetryPlugin(site, realTelemPort));
    openmct.install(HistoricalTelemetryPlugin(site, histTelemPort));
    openmct.install(LimitEval());


    openmct.start();
  </script>

  <!-- <div id="command">
    <input
      id="input-command"
      class="user-input"
      type="text"
      v-model="cmd"
      v-on:keyup.enter="sendCmd"
      v-on:keyup="searchCmd"
      placeholder="Enter command">

    <div id="cmdContainer">

      <ul id="cmd-search">
        <li
          v-for="command in cmdSearch">
          <p v-on:click="select(command, false)">{{ command['name'] + '( ' + command['args'] + ' )' }}</p>
        </li>
      </ul>

      <ul id="cmd-hist" >
        <li v-for="command in reverseCmd">
          <button v-on:click="select(command.cmd, true)">{{ command.cmd }}</button>
        </li>
      </ul>

    </div>

    <input
      id="input-search"
      class="user-input" 
      type="text"
      v-model="cmdHistQuery"
      v-on:keyup="searchHist"
      placeholder="Search history">
  </script> -->

  <!-- <script type="text/javascript">
    const site = 'localhost';
    const cmdPort = 1339;

    var socket = new WebSocket('ws://' + site + ':' + cmdPort.toString());

    getDictionary().then(function (dict) {
      let commandDict = dict['isf']['commands'];       
      let validCommands = [];
      for (id in commandDict) {
        let args = commandDict[id]['arguments'];
        let argFormat = args.map((a) => a['name'] + ' (' + a['type'] + ')');
        validCommands.push({
          'name': commandDict[id]['name'],
          'args': argFormat
        });
      }

      var command = new Vue({
        el: '#command',
        data: {
          cmd: '',
          cmdHist: [],
          cmdHistQuery: '',
          cmdHistToShow: [],
          cmdSearch: []
        },
        methods: {
          sendCmd: function (event) {
            // Add command and time
            socket.send(this.cmd);
            this.cmdHist.push({
              cmd: this.cmd,
              time: Date()
            });
            this.cmdHistToShow = this.cmdHist.slice();
            this.cmdSearch = [];  // Clear search
          },
          searchCmd: function (event) {
            if (this.cmd !== '') {
              this.cmdSearch = validCommands.filter((c) => c['name'].toLowerCase().indexOf(this.cmd) !== -1);
            } else {
              this.cmdSearch = [];
            }

            // Select from search results with arrow keys
            let i = 0;
            if (i >= 0 && i < this.cmdSearch.length) {
            // if(true) {
              console.log(event.key);
              switch(event.key) {
                case 'ArrowDown': {
                  this.select(this.cmdSearch[i += 1], false);

                  break;
                } 
                case 'ArrowUp': {
                  this.select(this.cmdSearch[i -= 1], false);

                  break;
                }
                case 'Escape': {
                  this.cmdSearch = [];

                  break;
                }

                default: {
                  // Nothing todo
                  break;
                }
              }
            }
          },
          select: function (command, hist) {
            if (hist) {
              // If selection is from history, select entire command with arguments
              this.cmd = command;
            } else {
              // Otherwise, just select command
              this.cmd = command['name'] + '(';
            }
            
          },
          searchHist: function () {
            if (this.cmdHistQuery !== '') {
              this.cmdHistToShow = this.cmdHist.filter((c) => c.cmd.indexOf(this.cmdHistQuery) !== -1);
            } else {
              this.cmdHistToShow = this.cmdHist.slice();
            }
          }
        },
        computed: {
          reverseCmd: function () {
            return this.cmdHistToShow.reverse()
          }
        }
      });
    });
  </script> -->

  <!-- JQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

  <!-- vue -->
  <script src="node_modules/vue/dist/vue.js" type="text/javascript"></script>

  <!-- Bootstrap -->
  <!-- <script src="node_modules/bootstrap/dist/js/bootstrap.min.js"></script> -->
</body>
</html>
