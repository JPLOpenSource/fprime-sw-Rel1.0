# Fprime OpenMCT Server

Author: Aaron Doubek-Kraft, aaron.doubek-kraft@jpl.nasa.gov

Expands on the openmct-telemetry-server, described in the "BSON Telemetry Server" section, to provide visualizations for binary
data streams. The OpenMCT server consumes a stream of BSON data, publishes it to
clients in real time, and stores it in a database for later historical access.
This deployment runs an adapter to convert fprime binary packets to BSON in the format required by the BSON server.
OpenMCT also ships with plugins to use Apache CouchDB to save and persist user-created
resources such as layouts. Telemetry visualization will work without running a CouchDB
server, but any user-created resources cannot be saved. Scripts are provided to
save and load persisted objects as JSON documents.

## Usage
This package requires node.js and npm to be installed on your system (https://nodejs.org/en/) to build and run.
Additionally, the build scripts depend on Python autocoders, so make sure your
system has Python 2, and install the "lxml" module.

To configure and start the OpenMCT server, run the following from fprime/openmct:
```
npm run configure <Topology XML Filepath>
npm start
```
where `<Topology XML Filepath>` is the Topology XML file for the fprime deployment for which OpenMCT will be receiving data. Point a browser to http://localhost:8000 to view the OpenMCT web client (Chrome works best).
If configuration was successful, a Packet object called "[Deployment Name] Telemetry"
containing Telemetry objects for each channel should appear under the "BSON Server" folder.

The BSON server folder also contains a "LIMIT_LOG" object, which records all limit violations in all channels, as well as a "Latest Values Table" object which shows the
most recent value and timestamp for all telemetry items.
To set up persistence for custom objects, see the "Persistence with CouchDB" section
below.

### Available NPM Scripts
```
npm install
```
This package ships with a frozen set of the JavaScript packages needed
to run the server, but running `install` will update packages if more recent
versions are available. These packages are located in the "node_modules" directory.

```
npm run configure <Topology XML Filepath>
```
Runs autocoders and scripts to generate a JSON dictionary and configuration
files from the provided fprime Topology XML file, which are needed by the OpenMCT server and adapter to interpret binary packets. For example, to configure the server for
the Ref application, run `npm run configure ../Ref/Top/RefTopologyAppAi.xml`.

```
npm start
```
Starts the OpenMCT telemetry server, web client server, and BSON Adapter. By
default the web client is served on http://localhost:8000. The BSON Adapter will continuously attempt to connect to the fprime telemetry server until it is running. By default,  it attempts to connect on http://localhost:50000.

```
npm run clean
```
Removes configuration files generated by the build scripts. Use this to clean up
all generated resources and start from scratch.

```
npm run couchdb-get
```
Queries the CouchDB HTTP API and constructs a JSON document representing all
user-created objects which have been saved to CouchDB in 'res/couchDBData.json'.
This document will be used to upload these objects when running `couchdb-set`.
This command will not work if the CouchDB server is not running at the domain
specified in 'config.js'.

```
npm run couchdb-set
```
Uses the CouchDB HTTP API to send local objects stored in 'res/couchDBData.json'
to the server. This command will not work if the CouchDB server is not running
at the domain specified in 'config.js'. The repository contains a sample JSON file
which will upload an "About OpenMCT" Webpage object to the database.

## Default Configuration

Configuration options for the BSON server are specified in the file 'config.js'. By default, the server is configured as follows (other configuration options are available, and documented in config.js):

| Option | Description| Default Value |
| --- | --- | --- |
| client.host | Hostname where web client will be served | localhost |
| client.port | Port where web client will be served | 8000 |
| client.persistence.type | Service to use for object persistence | couchdb |
| client.persistence.url | URL of object persistence database | http://localhost:5984/openmct |
| dictionary.pointsFile | Dictionary configuration for OpenMCT client, autocoded configuration file is saved here | res/points.json |
| dictionary.packetsFile | Dictionary configuration for OpenMCT client, autocoded configuration file is saved here | res/packets.json |
| input.type | Input type for openmct | bson |
| input.bindAddress | Hostname where BSON server listens for packets | 127.0.0.1 |
| input.port | Port where BSON server listens for packets | 12345 |
| binaryInput.deployment  | Deployment name to use for packet deserialization (this will be set to the appropriate key by the autocoder) | ref |
| binaryInput.bindAddress | Hostname where BSON Adapter will connect and receive binary packets | 127.0.0.1 |
| binaryInput.port | Port where BSON Adapter will connect and receive binary packets | 50000 |

## Persistence with CouchDB
A CouchDB server must be run as a standalone service in order to enable object persistence.
Download the appropriate version for your system from http://couchdb.apache.org/,
then do the following:
  1. Start the Apache CouchDB application
  2. In a browser, navigate to http://127.0.0.1:5984/_utils/ to open the GUI tools
      (this may happen automatically when you start CouchDB)
  3. Go to the Setup panel and choose "Configure a Single Node"
  4. Choose a username and password when prompted, using "127.0.0.1" as the host, and the default port of 5984
  5. From the Databases panel, create a new database called "openmct"
  6. Go to Configuration->CORS, choose "Enable CORS", and add http://localhost:8000
      to the allowed domains. This will allow OpenMCT read and write access to the
      database.

To test that this functionality is working, create a new item in the web client,
and save it to "My Items". Then, refresh the browser and observe that the item
is persisted.

# BSON Telemetry Server

Author: Pete Richards

This section describes the OpenMCT BSON server. This information is not necessary
to run the fprime server, but it is used internally in the implementation.

Basic Open MCT server with a built in telemetry server.  Consumes a stream of
BSON data, publishes it to clients in real time, and also stores it in a
database for historical access later.

Currently supports two different history stores-- an embedded store using LevelDB (just works out of the box) or a Redis based store.

The dictionary server will automatically track new points as it sees them in
the telemetry stream and expose them for Open MCT.  You can also have the dictionary service persist the current known dictionary to a file by POSTing `/save`.  You can have it reload the dictionary from file by POSTing to `/load`.

All configuration options for the BSON telemetry server are contained in `index.js` with documentation.

Usage:

```
› npm install
› npm start                                               

LevelDB: History will be stored in telemdb
LevelDB: History will keep latest 2 day(s) of data.
LevelDB: History will be pruned every 1 hour(s).
BSONStreamInput: Listening on: 127.0.0.1:12345
Web server running at 127.0.0.1:8000
```

## Point and Packet Dictionary
In order to provide Open MCT with the necessary information about available
points, point and packet dictionaries must be defined, and every point
must be mapped to a packet for it to be exposed in the client.  By default, the
server will automatically create and populate point and packet dictionaries
based on the information it gleans from the realtime stream.

Automatic packet generation can be customized.  Additionally, point to packet
mappings can be defined manually.

You can ask the server to persist it's current dictionaries to file via a POST
to the `/dictionary/save` endpoint.  The server will reload these files at
start up.  If you make changes to these files and want to reload them without
restarting the server, POST to `/dictionary/load`.

### Automatic point generation

The server will read type information from the bson messages stream and
automatically create point defintions for every unique mnemonic name.  These
can be manually edited by editing `points.json`.

### Automatic packet generation

There are three methods for automated packet generation.

**packetSeparator**
With no changes, the adapter will automatically detect packet names by splitting
point names using the `packetSeparator`.  It will only split on the first
`packetSeparator` found-- there is no concept of a nested packet. If the
`packetSeparator` is not found in the point name, then the adapter will add the
point to the "UNGROUPED POINTS" packet.

**packetPrefix**
You can specify a list of prefixes to group points by.  If more than one prefix
matches a point, the first match will be used for grouping.  If no matching
prefix is found, the server will fall back to the `packetSeparator` grouping
method above.

**manually editing packets.json**
You can modify the `packets.json` file to specify which points each packet
contains.  If a point is not found in the packets file, then the system will
fallback to the `packetPrefix` grouping method above.

## BSON output via socket

The BSON output module generates BSON messages which are output via a user-defined socket. The BSON specification can be found on http://bsonspec.org/

### BSON message format.

field name | description
--- | ---
name | A string containing the name of the mnemonic of this sample.
flags | An unsigned integer of the flags associated with the mnemonic sample. See the mnemonic flags table for decoding the flags value.
timestamp | A date value of the timestamp of this mnemonic sample. The date value is with respect to the UNIX epoch.
raw_type | An integer identifier of the type of the raw_value. See the value type identifier table for possible values.
raw_value | The raw value of the mnemonic sample.
eng_type | An integer identifier of the type of the eng_value. This key/value pair is only present if the mnemonic has a defined conversion. See the value type identifier table for possible values.
eng_val | The engineering value of the mnemonic sample. This key/value pair is only present if the mnemonic has a defined conversion.


### Mnemonic flags

flag | meaning
--- | ---
0x80000000 | Flag indicating mnemonic value has been set.
0x40000000 | The mnemonic value is static.
0x20000000 | The mnemonic value is of questionable quality.
0x04000000 | Flag indicating a conversion is enabled for the mnemonic.
0x02000000 | Flag indicating limit checking is enabled for the mnemonic.
0x01000000 | Flag indicating delta limit checking is enabled for the mnemonic.
0x00200000 | Flag indicating the mnemonic value sample triggered a delta limit violation.
0x00100000 | Flag indicating the mnemonic is in the red-high state of limit violation.
0x00080000 | Flag indicating the mnemonic is in the red-low state of limit violation.
0x00040000 | Flag indicating the mnemonic is in the yellow-high state of limit violation.
0x00020000 | Flag indicating the mnemonic is in the yellow-low state of limit violation.
0x00010000 | Flag indicating the mnemonic is within limits.
0x00008000 | Flag indicating the most recent limit transition was a red-high violation.
0x00004000 | Flag indicating the most recent limit transition was a red-low violation.
0x00002000 | Flag indicating the most recent limit transition was a yellow-high violation.
0x00001000 | Flag indicating the most recent limit transition was a yellow-low violation.
0x00000800 | Flag indicating the most recent limit transition was back within limits.
0x00000400 | Flag indicating the mnemonic is read-only.
0x00000200 | Flag indicating the mnemonic value is from a simulated source.

### Value type identifiers.

the docs appear incorrect.  I have experimentally checked and guessed what some values actually are.

documented value | experimental value | type
--- | --- | ---
63 | 71 | signed integer
64 | 72 | unsigned integer
65 | 73 | floating-point
66 | 74 | string
67 | 75 | time
68 | 76 | date
69 | 77 | raw (byte array)
